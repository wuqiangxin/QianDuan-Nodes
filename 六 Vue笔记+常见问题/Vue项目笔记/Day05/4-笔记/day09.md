# Day03

##0. 今日目标

1.修改用户,删除用户 

2.推送代码到码云 

3.权限列表 

4.角色列表 

5.分配角色

## 1. 修改用户

### 1.1 展示修改用户的对话框

1. 修改用户效果，我们先来处理点击修改，弹出对话框

   ![](img/修改用户效果.png)

2. 修改按钮，点击事件

   ![](img/修改点击事件.png)

3. 修改对话框结构（放到Users.vue中template的最底部）

   ![](img/修改对话框结构.png)

4. 用到的数据：添加到data中

   ![](img/数据.png)

5. 修改效果

   ![](img/修改效果.png)

### 1.2 根据Id查询对应的用户信息

1. 用户信息应该显示到弹出框中，所以我们需要点击修改按钮时，根据id查询用户信息

   ![](img/修改用户效果.png)

2. 获取用户信息接口

   ![](img/获取用户信息接口.png)

3. 获取用户信息

   ![](img/展示用户信息.png)

   - 这里需要将获取到的数据，存储起来，赋值给data中的editForm

4. editForm

   ![](img/查询用户数据.png)

   - editForm赋值之后，里边会有id，username，email，mobile，role_id属性

### 1.3 渲染修改用户的表单

1. 填充修改弹框，增加表单，增加校验规则

   ![](img/填充修改弹框.png)

   - 这里的editForm里并没有添加username，email，mobile
   - 其实在上一步我们给editForm赋值的时候，他已经具备这些属性了

2. 修改用户弹框：可以自动填充数据，并且做校验

   ![](img/修改用户弹框.png)

### 1.4 实现修改用户表单的重置操作

1. 重置逻辑

   ![](img/充值用户修改.png)

2. 演示：如果打开，然后原本不合法的手机号，经过失去焦点，有校验提示

   ![](img/问题.png)

3. 重新点开，验证内容已经被重置

   ![](img/重置.png)

   - 重置逻辑，可以将校验重置，也可以将文本框内容也进行重置（恢复默认）

### 1.5 完成提交修改之前的表单预验证

1. 点击确定，预验证效果

   ![](img/预验证效果.png)

2. 逻辑如下

   ![](img/修改确定逻辑.png)

### 1.6 提交表单完成用户信息的修改

1. 修改用户逻辑

   ![](img/修改用户.png)

   2. 修改成功之后，对话框关闭，并且用户列表的数据也刷新

## 2. 删除用户

### 2.1 弹框询问用户是否确认删除数据

1. 删除效果

   ![](img/删除.png)

2. 弹框官网：

   ![](img/消息盒子官网.png)

3. 删除逻辑

   ![](img/删除逻辑.png)

   - confirm方法返回了一个Promise对象，所以可以使用awiat
   - 当点击取消按钮时，confirm方法会抛出异常，所以需要调用catch，捕获错误

4. 注册MessageBox

   ![](img/注册messagebox.png)

   - 这里的MessageBox也是添加给Vue的原型对象了，跟Message一样

5. 效果：取消效果

   ![](img/取消效果.png)

### 2.2 调用API完成删除用户的操作

1. 删除用户api

   ![](img/删除用户api.png)

2. 删除逻辑如下：

   ![](img/删除逻辑02.png)

3. 效果：提示成功，并且列表中已经没有

   ![](img/删除效果.png)

### 2.3 创建user子分支并把代码推送到码云仓库中

1. 新建user分支

   ![](img/git01.png)

   - 老师这里的分支处于master（之前操作用户代码的时候，没有新建用户分支，而是直接在master上开发了）
   - 我们来修正一下

2. 在已经有修改的master分支上直接新建user分支，他会将所有修改都放入user分支中

   ![](img/git02.png)

3. 添加暂存区，提交本地仓库

   ![](img/git.png)

4. 提交user分支

   ![](img/git04.png)

5. 切换master，合并user

   ![](img/git05.png)

6. 提交master

   ![](img/git06.png)

## 3. 权限列表

### 3.1 创建rights子分支并推送到码云

1. 创建rights分支

   ![](img/git07.png)

   - 为了避免接下来开发权限相关代码，还是继续在主分支上开发
   - 我们在开发之前，新建rights分支

### 3.2 通过路由展示权限列表组件

1. 权限列表

   ![](img/权限列表.png)

2. 新建界面：components/power/Rights.vue

   ![](img/权限界面.png)

3. 注册权限界面

   ![](img/注册权限界面.png)

4. 权限效果

   ![](img/权限效果.png)

### 3.3 绘制面包屑导航和卡片视图

1. 权限面包屑和卡片

   ![](img/权限面包屑.png)

2. 权限界面结构

   ![](img/权限界面结构.png)

3. 权限效果

   ![](img/权限效果02.png)

   

### 3.4  调用API获取权限列表的数据

1. 获取权限接口

   ![](img/获取权限接口.png)

2. 权限列表代码

   ![](img/权限列表代码.png)

3. getRightsList方法

   ![](img/权限列表方法.png)

4. rightsList输出结果

   ![](img/获取到的数据.png)

### 3.5 渲染权限列表UI结构

1. 效果

   ![](img/效果02.png)

2. 卡片结构：使用表格

   ![](img/卡片结构.png)

3. 效果

   ![](img/效果.png)

4. 等级标签官网

   ![](img/tag官网.png)

5. 注册tag

   ![](img/注册tag.png)

6. 权限等级

   ![](img/权限登记.png)

   - 这里在做level判断的时候: level ==='0'，为啥是字符串0呢？

   - 引入level数据就是字符串的数字

     ![](img/level.png)

7. 效果

   ![](img/效果03.png)

### 3.6 用户-角色-权限 三者之间的关系

1. 权限管理分析

   ![](img/权限管理分析.png)

   - 角色：权限集合
   - 权限：每一个功能的增删改查，都可以认为是一个权限
   - 我们给用户赋予角色，他就拥有了这些角色下的权限

## 4. 角色列表

### 4.1  通过路由展示角色列表组件

1. 角色列表

   ![](img/角色列表.png)

2. 新建Roles.vue （同样在components/power中）

   ![](img/roles.png)

3. 注册roles

   ![](img/注册roles.png)

4. 角色效果

   ![](img/角色效果.png)

### 4.2 绘制基本布局结构并获取列表数据

1. 角色列表界面分析

   ![](img/角色列表界面分析.png)

2. 角色结构

   ![](img/角色结构.png)

3. 效果

   ![](img/角色列表效果.png)

4. 角色列表api

   ![](img/角色列表api.png)

5. 角色列表逻辑

   ![](img/角色逻辑.png)

6. 角色列表数据

   ![](img/角色列表数据.png)

### 4.3 渲染角色列表数据

1. 角色列表

   ![](img/table数据.png)

2. 角色列表结构

   ![](img/角色列表结构.png)

3. 效果

   ![](img/效果05.png)

4. 展开列

   ![](img/展开列.png)

   - type为expand就是展开列，expand：展开

5. 效果

   ![](img/效果04.png)

### 4.4 说明角色列表需要完成的功能模块

1. 展开功能如下（添加，编辑，删除，不在处理，跟用户一样）

   ![](img/功能.png)

2. 分配权限

   ![](img/分配权限.png)

### 4.5 分析角色下权限渲染的实现思路

1. 展开功能

   ![](img/功能.png)

2. 打印数据：pre，以预览格式查看数据

   ![](img/数据分析.png)

3. 数据分析如下

   ![](img/角色分析.png)

### 4.6 通过第一层for循环渲染一级权限

1. 一级结构如下：

   ![](img/一级结构.png)

   - scope.row是当前角色数据，scope.row.children是当前角色下的一级权限数据
   - item1，是一级菜单数据对象，i1是一级菜单的索引

2. 一级效果

   ![](img/一级效果.png)

   - 数据如下：这里的一级权限与显示的一致，没有问题

     ![](img/角色+权限数据.png)

### 4.7 美化一级权限的UI结构

1. 一级菜单样式

   ![](img/一级菜单样式.png)

   - 只有第一行添加顶部边框
   - 其余的添加底部边框

2. 效果

   ![](img/一级效果02.png)

3. icon官网

   ![](img/icon.png)

4. icon添加

   ![](img/icon添加.png)

5. 效果

   ![](img/一级效果03.png)

### 4.8 通过第二层for循环渲染二级权限

1. 二级菜单结构

   ![](img/渲染二级.png)

   - item1是一级权限，循环item1的children，就是二级权限，所以item2就是二级权限

2. 二级效果

   ![](img/二级效果.png)

   - 数据如下：商品管理下的二级权限为：商品列表，分类参数，商品分类，与上图显示一致，没问题

     ![](img/二级权限数据.png)

3. 二级添加样式

   ![](img/二级添加样式.png)

   - 除了第一个二级菜单，其他都添加一个顶部边框

4. 二级效果

   ![](img/二级效果02.png)

### 4.9 通过第三层for循环渲染三级权限

1. 三级结构

   ![](img/三级结构.png)

   - 循环item2的children，那么就是三级权限了，所以item3就是三级权限

2. 三级效果

   ![](img/三级效果.png)

   - 数据如下：商品列表下的三级权限为商品修改，与上图一致，没问题

     ![](img/三级权限.png)

3. 问题

   ![](img/问题02.png)

   - 在渲染一级权限的时候，分了两列，第一列显示一级权限，第二列显示二级和三级
   - 第一列占5份，第二列占19份（一行24份）
   - 然后在19份的列中，为了处理二级和三级，所有又增加了row，row里还是两个col
   - 这时候的第一列为6份，第二列为18份
   - 有同学问，6+18 != 19呀？这里大家需要注意每一行的分数都是24份
   - 在19份的这一列中又新增了一行，所以又将这19份分为了24份

4. 三级权限分析

   ![](img/三级权限分析.png)

### 4.10 美化角色下权限的UI结构

1. 菜单需要居中

   ![](img/一级菜单居中.png)

2. 垂直居中样式

   ![](img/垂直居中样式.png)

3. 一级菜单添加垂直居中

   ![](img/添加样式.png)

4. 二级也需要居中

   ![](img/添加样式02.png)

5. 居中效果

   ![](img/居中效果.png)

### 4.11 点击删除权限按钮弹出确认提示框

1. 删除权限

   - 每个权限都有叉号

   ![](img/删除权限.png)

   - 点击之后，出现对话框

     ![](img/删除确认.png)

2. 先给三级角色添加，删除图标

   ![](img/添加删除图标.png)

   - el-tag标签添加closable属性之后，就可以显示关闭按钮

3. 关闭按钮效果

   ![](img/删除图标添加.png)

4. 点击删除图标，需要弹框，所以需要监听删除事件

   ![](img/close事件.png)

5. 删除权限逻辑

   ![](img/删除权限逻辑.png)

6. 取消删除提示

   ![](img/取消删除提示.png)

### 4.12 完成删除角色下指定权限的功能

1. 删除权限逻辑

   - 传递参数

   ![](img/删除角色传递参数.png)

   - 当前这一行的数据scope.row，是角色数据，item3.id是三级权限的id
     - 删除权限，需要提供删除哪个角色下的权限，所以需要俩参数

   - 发起删除请求（**url依然是反引号包裹**）

     ![](img/删除逻辑03.png)

2. 问题：删除之后，权限内容合上了

   ![](img/删除之后合上.png)

   - 这是因为，我们在删除成功之后，调用了getRolesList()，而这个方法，会导致整个用户列表重绘，而权限默认是合上的，所以就合上了

3. 修复bug

   ![](img/修复合上.png)

   - 我们不在重新获取数据

   - 直接将res.data重新给当前角色赋值即可

   - 因为删除成功之后，后台服务器又将新的角色数据返回了

   - 我们只需要给这个角色数据重新赋值，他只会渲染角色这部分的数据，所以不会合上

   - 后台返回数据如下：data就是删除成功之后，返回的当前角色新权限列表

     ![](img/删除权限结果.png)

4. 一级二级权限添加删除逻辑

   ![](img/一级二级删除.png)

5. 效果

   ![](img/一级二级效果.png)

6. 分析图如下：

   ![](img/删除权限分析.png)

## 5. 分配权限

### 5.1 弹出分配权限对话框并请求权限数据

1. 分配权限对话框

   ![](img/分配权限03.png)

2. 对话框代码，添加到template末尾

   ![](img/分配权限对话框.png)

3. 分配权限点击，点击之后能够显示对话框

   ![](img/分配权限点击.png)

4. 效果

   ![](img/分配效果.png)

5. 所有权限列表接口：这次我们需要获取树形权限列表，所以参数值为tree

   ![](img/所有权限列表.png)

6. 保存权限列表的属性，一会要用，先定义

   ![](img/权限数据属性.png)

7. 获取树形权限

   ![](img/获取树形权限.png)

### 5.2 初步配置并使用el-tree树形控件 ***

1. 树形控件

   ![](img/树形菜单官网.png)

2. 树形结构

   ![](img/树形结构.png)

   - data是数据源，我们刚刚获取到的权限数据已经赋值给了rightsList

   - props：树形控件配置属性，通过这个属性确定树形控件显示什么内容，如何确定父子关系

     ![](img/属性绑定对象.png)

     - label：确定树形结构显示的内容的属性，显示权限名：authName（权限名）

     - children：确定树形结构的父子级关系的属性，我们的数据中'children'属性是表示父子关系的属性

     - 如下图：下边有分析图

       ![](img/树形角色api.png)

     - 分析如下：

       ![](img/tree控件props分析.png)

3. 注册tree

   ![](img/注册tree.png)

4. 树形权限效果

   ![](img/树形权限效果.png)

   - 树形数据如下：

     ![](img/树形权限.png)

### 5.3 优化树形控件的展示效果

1. 增加复选框效果

   ![](img/复选框.png)

2. 可选择的树形：增加show-checkbox即可

   ![](img/可选择的树形.png)

3. 添加复选框

   ![](img/添加复选框.png)

4. 复选框效果

   ![](img/复选框效果.png)

5. 增加node-key

   ![](img/nodekey.png)

   - 为啥要增加这个属性？
   - 当我们选中某个权限时，需要获取当前选中的权限的id
   - 菜单选中时，它会自己找node-key中的值是什么属性名，根据node-key的值来确定选中之后获取到的是哪个属性的值
   - 那么我们就通过node-key指定这个id属性即可

6. 添加nodekey

   ![](img/添加nodekey.png)

   - 注意，这里的node-key不需要属性绑定，我们只需要告诉他所以属性名字，他内部会找id属性的值
   - 这个后边会详细说（5.4），目前先知道不需要属性绑定即可

7. 再来看一个问题，打开之后，默认都是折叠的

   ![](img/默认折叠.png)

8. 展开所有官网介绍

   ![](img/展开所有.png)

9. 添加展开

   ![](img/添加展开.png)

10. 展开效果

   ![](img/展开效果.png)

### 5.4 分析已有权限默认勾选的实现思路

1. 当打开分配权限之后，应该默认勾选当前角色所拥有的权限

   ![](img/默认权限勾选.png)

2. 默认勾选属性

   ![](img/默认勾选属性.png)

   - 我们只需要给tree增加default-checked-keys属性，并且给定值。就可以实现默认选中

3. 增加默认勾选属性，并增加测试数据：105，116

   - 增加属性

     ![](img/增加默认属性.png)

   - 增加数据

   ![](img/默认选中.png)

4. 效果

   ![](img/默认选中效果.png)

   - 当我们将商品列表剩下的三级权限勾选之后，商品列表就自动勾选

   - 当商品管理下的所有二级权限勾选之后，商品管理自动勾选

   - 所以我们只需要将当前角色下的三级权限的数据给default-checked-keys即可

   - 但是需要注意：如果没有指定node-key是不行的

     ![](img/添加nodekey.png)

     - default-checked-keys如果指定了105和116，那么他就会找，看哪个节点的key是105和116，找到了就让对应的节点选中
     - 所以我们如果添加node-key为id的话，那么节点的key就是权限的id，这样才能通过default-checked-keys让其勾选

5. 如下，只需要获取主管这个角色下的所有三级权限，然后给default-checked-keys即可

   ![](img/分析.png)

6. 接下来我们就处理三级权限

### 5.5 加载当前角色已有的权限  ***

- 同递归的方式，获取当前角色下所有的三级权限

1. 增加递归方法，在methods中定义

   ![](img/递归方法.png)

   - node：是当前遍历的权限对象
   - arr：存储三级权限id的数组
   - leaf:叶子，最末端的意思，我们这里最末端的是三级权限
   - getLeafKeys获取三级权限id

2. 代码修改

   ![](img/添加参数.png)

   - showSetRightDialog增加参数role：这个是角色对象

3. 默认勾选效果

   ![](img/默认勾选效果.png)

4. **分析**

   ![](img/递归分析.png)

### 5.6 在关闭对话框时重置defKeys数组

1. 当我们打开测试角色的分配权限时，发现他应该只有商品管理和权限管理的权限，但是点击分配权限之后，进入有订单管理的权限

   ![](img/默认勾选问题.png)

2. 这是因为，我们先点击了主管的分配权限，他有订单管理，然后给defKeys添加了这些权限

   ![](img/默认勾选问题02.png)

   - 所以再点击测试角色的分配权限时，多了主管的权限，因为我们没有情况defKeys

3. 解决：关闭分配权限对话框时，清空defKeys

   ![](img/解决02.png)

### 5.7 调用API完成分配权限的功能

1. 处理确定分配

   ![](img/确定分配.png)

2. 角色授权api

   ![](img/角色授权api.png)

   - 这里的参数，需要选中的权限的key，还有半选中的权限的key

   - 下图：横岗就是半选中，对勾就是选中

     ![](img/半选中.png)

3. 获取选中，半选中的属性

   ![](img/获取选中权限.png)

   - 当

4. 定义属性：data中定义，这个后边要用

   ![](img/roleid.png)

5. roleId赋值

   ![](img/roleid赋值.png)

6. 分配权限代码：

   ![](img/分配代码.png)

   - el-tree添加ref='treeRef'，右侧代码中需要用到el-tree引用对象

   - ...this.$refs.treeRef.getCheckedKeys，是进行数组拆包

     - 比如：[1,2,3]-----1,2,3

   - 分配权限接口，要求将选中的权限和半选中的权限，全部以逗号拼接到一起，所以这里按照上述代码处理了一下

   - 分析如下：

     ![](img/分配权限参数分析.png)

7. 分配成功

   ![](img/分配成功.png)

### 5.8 渲染分配角色的对话框并请求角色列表数据

1. 分配角色

   ![](img/分配角色.png)

   ![](img/分配角色对话框.png	)

2. 增加分配角色对话框

   ![](img/增加分配角色对话框.png)

3. 分配角色属性

   ![](img/分配角色属性.png)

4. 分配角色对话框，需要显示用户信息，定义属性如下

   ![](img/userinfo.png)

5. 分配按钮事件：显示对话框，给userInfo赋值

   ![](img/显示分配对话框数据.png)

   - 将参数userInfo赋值给data的属性userInfo，下边对话框中才可以通过插值表达式使用

6. 增加对话框信息

   ![](img/对话框信息.png)

7. 效果

   ![](img/效果分配.png)

8. 还缺少一个角色的下拉列表框，这个需要用到角色列表属性，定义到data中：

   ![](img/角色列表属性.png)

9. 获取角色列表代码

   ![](img/获取角色列表.png)

10. 角色列表api如下

   ![](img/角色列表api.png)

11. 界面显示角色下拉菜单，下一小节处理

### 5.9 渲染角色列表的select下拉菜单

1. 角色下拉菜单如下

   ![](img/效果角色列表下拉.png)

2. 下拉菜单官网

   ![](img/select.png)

3. 下拉列表代码：

   ![](img/角色列表菜单.png)

   - label：下拉菜单每一项显示的内容：roleName角色名称
   - key和value都指定了：id角色id

   - rolesList的数据如下：每个角色对象都有id和roleName

     ![](img/角色列表数据2.png)

4. 注册下拉列表

   ![](img/注册select.png)

5. 角色列表下拉效果

   ![](img/效果角色列表下拉.png)

### 5.10 完成分配角色的功能

1. 分配用户角色api

   ![](img/分配用户角色api.png)

2. 更新角色代码

   ![](img/更新角色点.png)

3. 更新成功

   ![](img/更新成功.png)

4. 更新成功之后，再次打开，发现下拉列表没有重置

   ![](img/没有重置问题.png)

5. 重置代码

   ![](img/重置分配.png)

6. 重置效果

   ![](img/重置解决.png)

### 5.11 提交本地代码到Git仓库并推送到码云

1. 提交right

   ![](img/提交right.png)

2. 合并master

   ![](img/合并master.png)

