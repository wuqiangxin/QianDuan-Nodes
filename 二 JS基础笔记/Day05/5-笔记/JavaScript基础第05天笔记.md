# JavaScript基础第05天笔记

## 1.  作用域

### 1.1 作用域概述

- 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。
  - 简单理解：作用域就是**代码起作用的范围**
- 作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。
- JavaScript（ECMAScript6前）中的作用域有两种：
  - 全局作用域
  	 局部作用域（函数作用域）	

### 1.2 全局作用域

作用于所有代码执行的环境（整个 script 标签内部）或者一个独立的 js 文件。

### 1.3 局部作用域

作用于函数内的代码环境，就是**局部作用域**。 因为跟函数有关系，所以也称为**函数作用域**。

### 1.4 例子

```js
<script>
//全局作用域： 整个script标签 或者是一个单独的js文件
var num = 10;
var num = 30;
console.log(num);

//局部作用域（函数作用域） 在函数内部就是局部作用域 这个代码的名字只在函数内部起效果和作用
function fn() {
    // 局部作用域
    var num = 20;
    console.log(num);
}
fn();
</script>
```

### 1.5 JS没有块级作用域

- 块作用域由 { } 包括。

	 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：	

-   java有块级作用域：


  ```java
  if(true){
    int num = 123;
    system.out.print(num);  // 123
  }
  system.out.print(num);    // 报错
  ```

  以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；

  而与之类似的JavaScript代码，则不会报错：

-   Js中没有块级作用域（在ES6之前，ES6就是ECMAScript6）


  ```js
  if(true){
    var num = 123;
    console.log(123); //123
  }
  console.log(123);   //123
  ```

## 2.  变量的作用域

由作用域，衍生出来了变量作用域，也就是变量起作用的范围

在JavaScript中，根据作用域的不同，变量可以分为两种：

- 全局变量
- 局部变量

### 2.1 全局变量

在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下 var 声明的变量 是全局变量
- 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）
  - 这个也叫做隐式全局变量

### 2.2 局部变量

在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）

- 局部变量只能在该函数内部使用
- 在函数内部 var 声明的变量是局部变量
- 函数的形参实际上就是局部变量

### 2.3 例子

```js
//全局变量 ：在全局作用域下声明的变量叫做全局变量
var num = 10; // num就是一个全局变量
console.log(num);

function fn() {
    console.log(num);
}
fn();

// 2. 局部变量： 在局部作用域下的变量
function fun(aru) {// 注意： 函数的形参也可以看做是局部变量
    var num1 = 10; // num1就是局部变量 只能在函数内部使用
    num2 = 20;//隐式全局变量，不推荐使用
}
fun();
```

### 2.4 全局变量和局部变量的区别

- 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间

## 3.  作用域链 （了解）

只要是代码都在一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；

如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；

根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

案例分析1：

```js
function f1() {
    var num = 123;
    function f2() {
        console.log( num );
    }
    f2();
}
var num = 456;
f1();
```

![](images\图片1.png)

作用域链：采取就近原则的方式来查找变量最终的值。

```js
var a = 1;
function fn1() {
    var a = 2;
    var b = '22';
    fn2();
    function fn2() {
        var a = 3;
        fn3();
        function fn3() {
            var a = 4;
            console.log(a); //a的值 ?
            console.log(b); //b的值 ?
        }
    }
}
fn1();
```

![](images\图片2.png)

其实不用画图，也不用看图去分析，直接代码写好，格式化，采用就近原则查找即可。

**总结**：

1. 作用域链：函数嵌套函数，作用域中有作用域，形成作用域链。
2. 规律：采取就近原则的方式来查找变量最终的值。
3. 作用域链了解即可，因为真正开发的时候，函数嵌套之后，变量名不会起一样的名字

## 4.  预解析

### 4.1 预解析的相关概念

- JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。

- JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。

- 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义
  - **其实相当于提前读一遍代码，找var，function，将变量和函数声明进行提升**
  - 预解析也叫做变量、函数提升
- 代码执行： 从上到下执行JS语句


### 4.2 变量预解析

变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升

```js
console.log(num);  // 结果是多少？
var num = 10;      // ？
//结果：undefined

//注意：**变量提升只提升声明，不提升赋值**
```

### 4.3 函数预解析

函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数

```js
fn();
function fn() {
    console.log('打印');
}
//结果：控制台打印字符串 --- ”打印“ 

//注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	
```

### 4.4 函数表达式声明函数问题

函数表达式创建函数，会执行变量提升（因为是var关键字）

```js
fn();
var  fn = function() {
    console.log('想不到吧');
}
//结果：报错提示 ”fn is not a function"

//解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用
```

### 4.5 预解析案例

```js
// 预解析案例
// 案例1
var num = 10;
fun();

function fun() {
    console.log(num);
    var num = 20;
}
// 相当于执行了以下操作
// var num;

// function fun() {
//     var num;
//     console.log(num);
//     num = 20;
// }
// num = 10;
// fun();
// 案例2
var num = 10;

function fn() {
    console.log(num);
    var num = 20;
    console.log(num);
}
fn();
// // 相当于以下代码
// var num;

// function fn() {
//     var num;
//     console.log(num);
//     num = 20;
//     console.log(num);
// }
// num = 10;
// fn();
// // 案例3
var a = 18;
f1();

function f1() {
    var b = 9;
    console.log(a);
    console.log(b);
    var a = '123';
}
// 相当于以下代码
// var a;

// function f1() {
//     var b;
//     var a;
//     b = 9;
//     console.log(a);
//     console.log(b);
//     a = '123';
// }
// a = 18;
// f1();
// 案例4
f1();
console.log(c);
console.log(b);
console.log(a);

function f1() {
    var a = b = c = 9;
    console.log(a);
    console.log(b);
    console.log(c);
}
// 以下代码
// function f1() {
//     var a;
//     a = b = c = 9;
//     // 相当于 var  a  = 9; b = 9; c = 9; b 和 c 直接赋值 没有var 声明 当 全局变量看
//     // 集体声明  var a = 9, b = 9, c = 9;
//     console.log(a);
//     console.log(b);
//     console.log(c);
// }
// f1();
// console.log(c);
// console.log(b);
// console.log(a);
```

### 4.6 总结

- 预解析：**提前读一遍代码，找var，function，将变量声明和函数声明进行提升**
- 预解析做两件事情：***

```js
//1.变量声明提升 ：变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。
var num = 1;
var xx = function(){}//注意这个会做变量声明提升（隐身函数表达式本质上是定义了一个变量）
//2.函数声明提升 ：函数的声明会被提升到当前作用域的最上面，但是不会调用函数。
function xx(){}
```

- 预解析在工作中正常开发用不到，因为一般是先定义变量/函数，再去使用。
- 但是在面试，考试中经常考，所以还是需要掌握

## 5.  对象

### 5.1 对象的相关概念

#### 5.1.1 什么是对象？

- 在 JavaScript 中，**对象是一组无序的相关属性和方法的集合**，所有的事物都是对象，例如字符串、数值、数组、函数等。
-  对象是由属性和方法组成的

  - 属性：**事物的特征**，在对象中用属性来表示（常用名词）

  - 方法：**事物的行为**，在对象中用方法来表示（常用动词）

    ![](images\图片3.png)

#### 5.1.2 为什么需要对象？

- 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。

- 如果要保存一个人的完整信息呢？

- 例如，将“张三疯”的个人的信息保存在数组中的方式为：


```js
  var arr = [‘张三疯’, ‘男', 128,154];
```

- 上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。

- **为了让更好地存储一组数据，对象应运而生**：**对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用**。

- 使用对象记录上组数据为：


```js
 var obj = {
      "name":"张三疯",
      "sex":"男",
      "age":128,
      "height":154
  }
```

- **JS中的对象表达结构更清晰，更强大**。


#### 5.1.3 **总结：*****

- 万物皆对象，对象是 一个具体的事物 ，看得见摸得着的实物。例如，一本书、一辆汽车
- 在 JavaScript 中，对象是一组无序的相关属性和方法的集合
- 为啥要有对象：为了方便管理多个变量，和多个函数
- 对象中的变量，称之为属性 
- 对象中的函数，称之为方法 

### 5.2 创建对象的三种方式

#### 5.2.1 利用字面量创建对象 *** （平常写代码采用的方式） 

##### 5.2.1.1 语法

- 语法如下

```js
var obj = {key:value,key2:value2...};
```

- key键：相当于属性名

- value值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）

  - 在对象中的方法，也可以理解为是一个属性，可以称之为方法属性

- 代码如下：

  ```js
  var star = {// star即是创建的对象。
      name : 'pink',
      age : 18,
      sex : '男',
      sayHi : function(){
          alert('大家好啊~');
      }
  };
  ```


##### 5.2.1.2 对象的使用

- 访问对象的属性

  ```js
  //1.点语法：对象.属性
  console.log(star.name)
  //2.中括号语法：对象['属性']
  console.log(star['name'])
  ```

- 调用对象的方法

  ```js
  //1.点语法：对象.方法()
  star.sayHi(); // 调用方法,注意，一定不要忘记带后面的括号
  //2.中括号语法：对象['方法']()
  star['sayHi']();
  ```

- **总结**
  - 其实调用属性和方法语法都一样
  - 只不过方法需要添加小括号
  - 方法，也可以称之为属性，可以叫做方法属性

##### 5.2.1.3 变量、属性、函数、方法总结

- 属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器
    - 变量：单独声明赋值，单独存在
    - 属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征

- 方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器
  - 函数：单独存在的，通过“函数名()”的方式就可以调用
  - 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。 
- **总结**：
  - 对象中的变量，称之为属性 
  - 对象中的函数，称之为方法 

##### 5.2.1.4 对象与数组 ***

我们来对比一下普通对象和数组对象（数组也是对象）。

1. 声明：

    ```js
    var star = {
        name : 'pink',
        age : 18,
        sex : '男',
        sayHi : function(){
            alert('大家好啊~');
        }
    };
    var arr = [1,2,3];  
    var arry = [
        0: 1,
        1: 2,
        2: 3
    ];
    ```

2. 存储结构：

		都是key:value
	对象的key是：属性名
	数组的key是：索引

3. 获取： 都是通过key获取value

  ```js
  star['name'];//通过中括号key获取对象的value，需要添加引号。
  
  arr[0];//数组的索引不需要添加引号
  
  //对象还有一种特殊的方式，点语法
  star.name;
  
  ```

##### 5.2.1.5 课堂练习

```js
//请用对象字面量的形式创建一个名字为可可的狗对象。   
//具体信息如下：
//姓名：可可 
//类型(type)：阿拉斯加犬
//年龄：5岁，
//颜色：棕红色。  
//技能：汪汪汪(bark) ，演电影 (showFilm)
var dog = {
    name: '可可',
    type: '阿拉斯加犬',
    age: 8,
    color: '棕红色',
    bark: function() {
        alert('汪汪汪');
    },
    showFilm: function() {
        alert('我会演电影');
    }
}
console.log(dog.name);
dog.bark();
```

#### 5.2.2 利用 new Object 创建对象 ***（webapis经常用的方式） 

- 创建空对象

  ```js
  var andy = new Object();
  ```

  通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象

  构造函数，后边解释

- 给空对象添加属性和方法

  示例代码如下：

  ```js
  andy.name = 'pink';//给andy添加name属性，并赋值
  andy.age = 18;
  andy.sex = '男';
  andy.sayHi = function(){//给andy添加sayHi方法，并赋值
      alert('大家好啊~');
  }
  ```

- 注意：

  - Object() ：第一个字母大写   
  - new Object() ：需要 new 关键字
  - 使用的格式：对象.属性 =  值;     

- 课堂练习：

  ```js
  //请用new Object 形式创建一个鸣人对象。   
  //具体信息如下：  
  //姓名：鸣人  
  //性别：男 
  //年龄：19岁  
  //技能（skill）：影分身术
  var nld = new Object();
  nld.name = '鸣人';
  nld.sex = '男';
  nld.age = 19;
  nld.skill = function() {
  	alert('色诱术');
  }
  ```

#### 5.2.3 利用构造函数创建对象  (比较复杂的逻辑时采用的方式)

##### 5.2.3.1 为啥需要构造函数

- 因为我们一次创建一个对象，里面很多的属性和方法是大量相同的 我们只能复制 
- 因此我们可以利用函数的方式，封装这些重复的代码
- 又因为这个函数不一样，里面封装的不是普通代码，而是**创建对象的代码**，所以叫构造函数  
- 构造函数，就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面
- 构造函数： **特殊的函数，能够构造对象（创建对象）的函数**

##### 5.2.3.2 语法

- 定义构造函数的语法如下：

  ```js
  function 构造函数名(形参1,形参2,形参3) {// 构造函数的形参与对象的普通属性是一致的
       this.属性名1 = 形参1;//形参就是要给属性赋值
       this.属性名2 = 形参2;
       this.属性名3 = 形参3;
       this.方法名 = 匿名函数;//匿名函数不需要传递
  }
  ```

- 构造函数的调用语法：**通过new调用**

  ```js
  var obj = new 构造函数名(实参1，实参2，实参3)
  ```

  以上代码中，obj即接收到构造函数创建出来的对象。

- 注意事项

  1.   构造函数约定**首字母大写**。
  2.   函数内的属性和方法前面需要添加 **this** ，表示当前对象的属性和方法。
  3.   构造函数中**不需要 return 返回结果**。
  4.   当我们创建对象的时候，**必须用 new 来调用构造函数**。

- 例子  (构造函数(**构**建创**造**对象 )的作用：就是用来创建对象(创造对象)，并且给对象添加属性和方法(构建对象)***)

   ```js
   //需求：定义一个人类构造函数，创建的人类对象包含属性：姓名，年龄，性别，方法：打招呼。
   function Person(name, age, sex) {   //***  构造函数的参数与对象的普通属性是一致的。
      // 1. 创建了对象this  js内部做的第一件事情 ***
      //var  this = new Object();
      this.name = name;// 属性的值，都是通过同名的形参来赋值的
      this.age = age;
      this.sex = sex;
      this.sayHi = function() { //函数不需要通过形参来赋值
          alert('我的名字叫：' + this.name + '，年龄：' + this.age + '，性别：' + this.sex);
      }
      //return this;   2. js内部做的第二件事情 ***
   }
   // 创建出来一个大白的人类对象，大白的名字是大白，100，男
   var bigbai = new Person('大白', 100, '男'); // var bigbai = this; 
   // this 就是即将创建出来的大白对象// this:这个，这个对象
   console.log(bigbai.name);// 大白
   
   var smallbai = new Person('小白', 21, '男');
   console.log(bigbai.name);
   console.log(smallbai.name);
   ```

   ```js
   //明星构造函数
   function Star(name, age, sex) {
       this.name = name;
       this.age = age;
       this.sex = sex;
       this.sing = function(sang) {
           console.log(sang);
   
       }
   }
   var ldh = new Star('刘德华', 18, '男'); 
   console.log(ldh.name);
   console.log(ldh['sex']);
   ldh.sing('冰雨');
   ```

##### 5.2.3.3 课堂练习

```js
// 利用构造函数创建两个英雄对象。 函数中的公共部分包括： 姓名属性(name)， 类型属性（ type），
// 血量属性（ blood） 和攻击方式（ attack）。
// 英雄对象的信息如下：
// 廉颇 力量型 500 血量 攻击： 近战
// 后羿 射手型 100 血量 攻击： 远程
function Hero(name, type, blood) { // 构造函数的参数，就是对象的属性
    // this.xxx = xxx;
    this.name = name;
    this.type = type;
    this.blood = blood;
    this.attack = function(attackType) {
        alert('我的攻击类型是：' + attackType);
    };
}
var lianPo = new Hero('廉颇', '力量型', '500');
console.log(lianPo.name);
lianPo.attack('近战');
```

##### 5.2.3.4 构造函数与对象的区别

- 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它**泛指某一大类**（class）  
  创建对象，如 new Stars()，**特指某一个（具体的某一个）**，通过 new 关键字创建对象的过程我们也称为对象实例化
- **实例：就是实际的例子**（某一大类中的实际的例子）
- 对象又叫做实例
- 创建对象的过程，也叫做实例化/对象化
- 具体区别如下图：（下图中的类先了解即可，是在es6中才会讲解）

![](images\构造函数对象区别.jpg)

- new关键字的作用

1. 在构造函数代码开始执行之前，创建一个空对象；
2. 修改this的指向，把this指向创建出来的空对象；
3. 执行函数的代码
4. 在函数完成之后，返回this---即创建出来的对象

### 5.3 遍历对象

- for...in 语句用于对数组或者对象的属性进行循环操作。

- 其语法如下：

  ```js
  for (变量 in 对象名字) {
      // 在此执行代码
  }
  ```

- 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。

  ```js
   var obj = {
       name: 'pink老师',
       age: 18,
       sex: '男',
       fn: function() {}
   };
  for (var k in obj) {//for in遍历obj，其实遍历的是obj中的属性 ['name','age']
      console.log(k);       // 这里的 k 是属性名 （字符串）  ‘name’,'age'
      console.log(obj[k]); // 这里的 obj[k] 是属性值  obj['name'] obj['age']
  }
  // obj.k  , obj['k']// 找obj中属性名字叫做k的属性的值
  // obj[k]  // 先找变量k，拿到k的值，然后再去obj中查找
  // 如果遍历第一次： k = ‘name’ ，obj['name']
  
  // 结论： 中括号语法  ****
  // 如果带上引号，引号中是属性名
  // 如果没有带引号，说明是变量名
  ```

- **理解**：forin遍历，其实是在变量obj对象中的所有属性k，然后我们可以根据k获取属性值

- 其实跟普通for循环，变量数组是一样的（**都是遍历key，根据key获取value**）

  ```js
  var arr = ['a','b']  ;//[0:a,1:b]
  for (var i=0;i<arr.length;i++){  // i是 数组的啥呢？索引 ， key
      i;  // 0,1
      arr[i]; // a ,b 
  }
  ```